---
title: "Basic Usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic Usage}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.retina = 3,
  comment = "#>"
)
library(logitr)
# Read in results from already estimated models  so that the
# examples aren't actually run when building this page, otherwise it'll
# take much longer to build
mnl_pref <- readRDS(here::here('inst', 'extdata', 'mnl_pref.Rds'))
mnl_wtp  <- readRDS(here::here('inst', 'extdata', 'mnl_wtp.Rds'))
```

```{r, child=here::here('man', 'rmdchunks', 'header.Rmd')}
```

## Data format

```{r, child=here::here('man', 'rmdchunks', 'dataFormat.Rmd')}
```

The ["Data Formatting and Encoding"](data_formatting.html) vignette has more details about the required data format.

## Model specification interface

Unlike most other similar packages, package {logitr} does not use the `formula` class to specify the model covariates and instead uses a vector of the covariates names. Each element in the vector is additively included as a covariate in the utility model, with the interpretation that they represent _utility_ parameters in preference space models and _WTP_ parameters in a WTP space model. While this design choice is a departure from the popular formula interface used in other similar packages such as {mlogit}, it was chosen to avoid confusion when switching between estimating preference space and WTP space models.


The basic usage for estimating models is as follows:

```{r, eval=FALSE}
model <- logitr(
  data,
  choice,
  obsID,
  pars
  ...
)
```

For example, consider a preference space model where the observed utility for yogurt purchases is given by $v_{j} = \alpha p_{j} + \beta_1 x_{j1} + \beta_2 x_{j2}$, where $p_{j}$ is `price`, $x_{j1}$ is `feat`, and $x_{j2}$ is `brand`. This model can be estimated using the `logitr()` function as follows:

```{r, eval=FALSE}
mnl_pref <- logitr(
    data   = yogurt,
    choice = "choice",
    obsID  = "obsID",
    pars   = c("price", "feat", "brand")
)
```

To instead estimate a WTP space model, the user can simply move the `"price"` covariate from the `pars` argument to the `price` argument and change the `modelSpace` argument value from `"pref"` to `"wtp"` (`"pref"` is the default value):

```{r, eval=FALSE}
mnl_wtp <- logitr(
    data   = yogurt,
    choice = "choice",
    obsID  = "obsID",
    pars   = c("feat", "brand"),
    price  = "price",
    modelSpace = "wtp"
)
```

In this case, the observed utility is $v_{j} = \lambda \left(\omega_1 x_{j1} + \omega_2 x_{j2} - p_{j}\right)$, where $p_{j}$ is `price`, $x_{j1}$ is `feat`, and $x_{j2}$ is `brand`.

Note that for WTP space models the `pars` argument should _not_ contain the name of the column for the price attribute because there is no estimated "price" parameter in WTP space models. Instead, a "scale" parameter given by $\lambda$ will be estimated, and the column for "price" should be provided separately using the `price` argument.

Both of these examples are multinomial logit models with fixed parameters. See the ["Estimating Multinomial Logit Models"](mnl_models.html) vignette for more details.

## Multi-start estimation

Since WTP space models have non-convex log-likelihood functions, it is recommended to use a multi-start search to run the optimization loop multiple times to search for different local minima. This is implemented using the `numMultiStarts` argument, e.g.:

```{r}
mnl_wtp <- logitr(
    data   = yogurt,
    choice = "choice",
    obsID  = "obsID",
    pars   = c("feat", "brand"),
    price  = "price",
    modelSpace = "wtp",
    numMultiStarts = 10
)
```

## Mixed logit models

To estimate a mixed logit model, use the `randPars` argument in the `logitr()` function to denote which parameters will be modeled with a distribution. The current package version supports normal (`"n"`) and log-normal (`"ln"`) distributions.

For example, assume the observed utility for yogurts is given by $v_{j} = \alpha p_{j} + \beta_1 x_{j1} + \beta_2 x_{j2}$, where $p_{j}$ is `price`, $x_{j1}$ is `feat`, and $x_{j2}$ is `brand`. To model the `"feat"` and `"brand"` parameters as normally distributed, set `randPars = c(feat = 'n', brand = 'n')`:

```{r, eval=FALSE}
mxl_pref <- logitr(
    data     = yogurt,
    choice   = 'choice',
    obsID    = 'obsID',
    pars     = c('price', 'feat', 'brand'),
    randPars = c(feat = 'n', brand = 'n'),
    numMultiStarts = 10
)
```

Since mixed logit models also have non-convex log-likelihood functions, it is again recommended to use a multi-start search to run the optimization loop multiple times to search for different local minima.

See the ["Estimating Mixed Logit Models"](mxl_models.html) vignette for more details.

## View results

Use the `summary()` function to print a summary of the results from an estimated model, e.g.

```{r}
summary(mnl_pref)
```

Use `statusCodes()` to print a description of each status code from the `nloptr` optimization routine.

You can also extract other values of interest at the solution, such as:

**The estimated coefficients**

```{r}
coef(mnl_pref)
```

**The log-likelihood**

```{r}
logLik(mnl_pref)
```

**The variance-covariance matrix**

```{r}
vcov(mnl_pref)
```

**The coefficient standard errors**

```{r}
sqrt(diag(vcov(mnl_pref)))
```

## Computing and comparing WTP

For models in the preference space, a summary table of the computed WTP based on the estimated preference space parameters can be obtained with the `wtp()` function. For example, the computed WTP from the previously estimated fixed parameter model can be obtained with the following command:

```{r}
wtp(mnl_pref, price = "price")
```

The `wtp()` function divides the non-price parameters by the negative of the price parameter. Standard errors are estimated using the Krinsky and Robb parametric bootstrapping method [@Krinsky1986]. Similarly, the `wtpCompare()` function can be used to compare the WTP from a WTP space model with that computed from an equivalent preference space model:

```{r}
wtpCompare(mnl_pref, mnl_wtp, price = "price")
```

## Predicting choice probabilities

Estimated models can be used to predict expected choices and choice probabilities for a set (or multiple sets) of alternatives based on an estimated model. As an example, consider predicting choice probabilities for two of the choice observations from the `yogurt` dataset:

```{r}
alts <- subset(
  yogurt, obsID %in% c(42, 13),
  select = c('obsID', 'alt', 'choice', 'price', 'feat', 'brand')
)

alts
```

In the example below, the expected choice probabilities for these two sets of alternatives are computed using the fixed parameter `mnl_pref` model:

```{r}
probs <- predictProbs(
  model = mnl_pref,
  alts  = alts,
  altID = "alt",
  obsID = "obsID"
)

probs
```

The resulting `probs` data frame contains the expected choice probabilities for each alternative. The low and high values show a 95% confidence interval, estimated using the Krinsky and Robb parametric bootstrapping method [@Krinsky1986]. You can change the CI level by setting alpha to a different value (e.g. a 90% CI is obtained with alpha = 0.05).

Choice probabilities can also be predicted used WTP space models. For example, the predicted choice probabilities using the `mnl_wtp` model are nearly identical with those from the `mnl_pref` model:

```{r}
probs <- predictProbs(
  model = mnl_wtp,
  alts  = alts,
  altID = "alt",
  obsID = "obsID"
)

probs
```

See the ["Predicting Choice Probabilities from Estimated Models"](predict_probs.html) vignette for more details.

## Predicting choices

Similar to the `predictProbs()` function, the `predictChoices()` function can be used to predict choices using the results of an estimated model. In the example below, choices are predicted for the entire `yogurt` dataset, which was used to the estimate the `mnl_pref` model:

```{r}
choices <- predictChoices(
  model = mnl_pref,
  alts  = yogurt,
  altID = "alt",
  obsID = "obsID"
)

# Preview actual and predicted choices
head(choices[c('obsID', 'choice', 'choice_predict')])
```

The resulting `choices` data frame contains the same `alts` data frame with an additional column, `choice_predict`, which contains the predicted choices. You can quickly compute the accuracy by dividing the number of correctly predicted choices by the total number of choices:

```{r}
chosen <- subset(choices, choice == 1)
chosen$correct <- chosen$choice == chosen$choice_predict
sum(chosen$correct) / nrow(chosen)
```

See the ["Predicting Choices from Estimated Models"](predict_choices.html) vignette for more details.
